/**
 * Licensed to Apereo under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Apereo licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License.  You may obtain a
 * copy of the License at the following location:
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.jasig.ssp.service.impl;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.base.Splitter;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.jasig.ssp.model.ObjectStatus;
import org.jasig.ssp.model.Person;
import org.jasig.ssp.model.SuccessIndicatorEvaluationType;
import org.jasig.ssp.model.external.*;
import org.jasig.ssp.model.reference.Blurb;
import org.jasig.ssp.model.reference.SuccessIndicator;
import org.jasig.ssp.service.EvaluatedSuccessIndicatorService;
import org.jasig.ssp.service.MapStatusService;
import org.jasig.ssp.service.ObjectNotFoundException;
import org.jasig.ssp.service.PersonService;
import org.jasig.ssp.service.TaskService;
import org.jasig.ssp.service.external.*;
import org.jasig.ssp.service.reference.BlurbService;
import org.jasig.ssp.service.reference.SuccessIndicatorService;
import org.jasig.ssp.transferobject.EvaluatedSuccessIndicatorTO;
import org.jasig.ssp.transferobject.SuccessIndicatorEvaluation;
import org.jasig.ssp.transferobject.external.AbstractPlanStatusReportTO;
import org.jasig.ssp.transferobject.jsonserializer.DateOnlyFormatting;
import org.jasig.ssp.util.SspStringUtils;
import org.jasig.ssp.util.collections.Pair;
import org.jasig.ssp.util.sort.PagingWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.UnexpectedRollbackException;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
import org.springframework.util.PatternMatchUtils;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import static org.jasig.ssp.util.sort.SortingAndPaging.allActive;


@Service
public class EvaluatedSuccessIndicatorServiceImpl implements EvaluatedSuccessIndicatorService {

    private static final Logger LOGGER = LoggerFactory
            .getLogger(EvaluatedSuccessIndicatorServiceImpl.class);
    private static final int DECIMAL_SCALE = 49;
    private static final RoundingMode ROUNDING_MODE = RoundingMode.HALF_UP;
    private static final Function<String, String> LOWER_CASER = new Function<String, String>() {
        @Override
        public String apply(@Nullable String input) {
            return input.toLowerCase();
        }
    };
    private static final Predicate<String> BLANK_STRING_TEST = new Predicate<String>() {
        @Override
        public boolean apply(@Nullable String input) {
            return StringUtils.isBlank(input);
        }
    };
    private static final Predicate<String> NON_BLANK_STRING_TEST = new Predicate<String>() {
        @Override
        public boolean apply(@Nullable String input) {
            return !(BLANK_STRING_TEST.apply(input));
        }
    };
    // Must generate keys corresponding to those generated by RISK_SUCCESS_INDICATOR_MAP_KEY_GENERATOR
    private static final Function<ExternalStudentRiskIndicator, String> RISK_INDICATOR_MAP_KEY_GENERATOR =
            new Function<ExternalStudentRiskIndicator, String>() {
        @Override
        public String apply(@Nullable ExternalStudentRiskIndicator input) {
            return new StringBuilder(input.getModelCode()).append("::").append(input.getIndicatorCode()).toString();
        }
    };
    // Must generate keys corresponding to those generated by RISK_INDICATOR_MAP_KEY_GENERATOR
    private static final Function<SuccessIndicator, String> RISK_SUCCESS_INDICATOR_MAP_KEY_GENERATOR =
            new Function<SuccessIndicator, String>() {
                @Override
                public String apply(@Nullable SuccessIndicator input) {
                    return new StringBuilder(input.getModelCode()).append("::").append(input.getCode()).toString();
                }
            };
    private static final Function<Blurb, String> BLURB_MAP_KEY_GENERATOR =
            new Function<Blurb, String>() {
                @Override
                public String apply(@Nullable Blurb input) {
                    return input.getCode();
                }
            };
    private static final String TRANSCRIPT_INDICATOR_METRIC_KEY = "TRANSCRIPT";
    private static final String FINANCIAL_AID_INDICATOR_METRIC_KEY = "FINANCIAL_AID";
    private static final String EXTERNAL_RISK_INDICATOR_METRIC_KEY = "EXTERNAL_RISK";
    private static final String EVALUATION_DISPLAY_NAMES_KEY = "DISPLAY_NAMES";
    private static final String CURRENT_TERM_KEY = "CURRENT_TERM";
    private static final String BLURB_SEPARATOR = ".";
    private static final String EVALUATION_DISPLAY_NAMES_BLURB_PREFIX = "ssp.success.indicator.evaluation";
    private static final String EVALUATION_DISPLAY_NAMES_BLURB_QUERY = EVALUATION_DISPLAY_NAMES_BLURB_PREFIX
            + BLURB_SEPARATOR + "*";


    @Autowired
    private SuccessIndicatorService successIndicatorService;

    @Autowired
    private ExternalStudentTranscriptService externalStudentTranscriptService;

    @Autowired
    private RegistrationStatusByTermService registrationStatusByTermService;

    @Autowired
    private TermService termService;

    @Autowired
    private PersonService personService;

    @Autowired
    private TaskService taskService;

    @Autowired
    private MapStatusService mapStatusService;

    @Autowired
    private ExternalStudentFinancialAidService externalStudentFinancialAidService;

    @Autowired
    private ExternalStudentRiskIndicatorService externalStudentRiskIndicatorService;

    @Autowired
    private transient ExternalStudentTranscriptCourseService externalStudentTranscriptCourseService;

    @Autowired
    private BlurbService blurbService;

    @Autowired
    private PlatformTransactionManager platformTransactionManager;

    private ThreadLocal<Map<String,Object>> evaluationResourceCache = new ThreadLocal<>();


    @Override
    public List<EvaluatedSuccessIndicatorTO> getForPerson(final UUID personId, final ObjectStatus status, final
                                    List<SuccessIndicator> indicators) throws ObjectNotFoundException {

        // Elaborate transaction management workaround b/c we can't avoid opening a transaction, but any exception
        // that crosses a transactional boundary in the code will mark the transaction as rollback only, which is
        // fine except that if we just tag this method with @Transactional(readOnly=true), the transaction manager
        // will still attempt a commit if the exception doesn't exit all the way out of this method (which is
        // what we usually want in this specific case - we want to try to return as many indicators as we can). And
        // if you attempt to commit a transaction marked as rollback only, you get a
        // org.springframework.transaction.UnexpectedRollbackException
        TransactionTemplate transactionTemplate = new TransactionTemplate(platformTransactionManager);
        transactionTemplate.setReadOnly(true);
        final AtomicReference<List<EvaluatedSuccessIndicatorTO>> rsltHolder = new AtomicReference<>();
        final AtomicReference<ObjectNotFoundException> onfeHolder = new AtomicReference<>();
        try {
            transactionTemplate.execute(new TransactionCallbackWithoutResult() {
                @Override
                protected void doInTransactionWithoutResult(TransactionStatus txnStatus) {
                    try {
                        getForPersonInTransaction(personId, status, indicators, rsltHolder);
                    } catch ( ObjectNotFoundException e ) {
                        onfeHolder.set(e);
                        throw new RuntimeException("Rolling back transaction", e);
                    }
                }
            });
        } catch ( UnexpectedRollbackException e ) {
            // nothing to be done, totally normal. see comments above.
        } catch ( RuntimeException e ) {
            if ( onfeHolder.get() == null ) {
                throw e;
            } // otherwise it's just us, rolling back the transaction, nothing to be done, totally normal
        }

        if ( onfeHolder.get() != null ) {
            throw onfeHolder.get();
        }

        return rsltHolder.get();
    }

    private void getForPersonInTransaction(UUID personId, ObjectStatus status, List<SuccessIndicator> possibleSubsetOfIndicators,
                                           AtomicReference<List<EvaluatedSuccessIndicatorTO>> rsltHolder) throws ObjectNotFoundException {

        final Person person = findPersonOrFail(personId);

        final PagingWrapper<SuccessIndicator> successIndicators;
        if (CollectionUtils.isEmpty(possibleSubsetOfIndicators)) {
            successIndicators = successIndicatorService.getAll(allActive());
        } else {
            successIndicators = new PagingWrapper<>(possibleSubsetOfIndicators);
        }

        if ( successIndicators.getResults() <= 0L ) {
            rsltHolder.set(Lists.<EvaluatedSuccessIndicatorTO>newArrayListWithCapacity(0));
            return;
        }

        final ArrayList<EvaluatedSuccessIndicatorTO> evaluations =
                Lists.newArrayListWithExpectedSize((int) successIndicators.getResults());
        evaluationResourceCache.set(Maps.<String, Object>newLinkedHashMap());
        try {
            for ( SuccessIndicator successIndicator : successIndicators ) {
                try {
                    final List<EvaluatedSuccessIndicatorTO> evaluation = evaluate(successIndicator, person);
                    if ( evaluation != null ) {
                        evaluations.addAll(evaluation);
                    }
                } catch ( Exception e ) {
                    // This rarely happens b/c evaluate() should be catching nearly all problems since the goal
                    // is to aways return an evaluation TO with as much possible info for all active indicators, even
                    // if the eval fails. If we tried to do that here, we wouldn't be able to output metric values in
                    // the TO, for example. So while this is a handled exception, it does indicate a more serious
                    // problem (probably a bad indicator code) than elsewhere in this class, so logging at a higher
                    // level.
                    LOGGER.error("System failure evaluating success indicator [{}] for person [{}]",
                            new Object[]{ successIndicatorLoggingId(successIndicator), person.getId(), e });
                }
            }
        } finally {
            evaluationResourceCache.set(null);
        }
        rsltHolder.set(evaluations);
    }

    private static class SuccessIndicatorMetric {
        private Object rawValue;
        private String displayValue;
        private String displayValueDescription;
        private String code;
        private String name;

        private SuccessIndicatorMetric() {}

        private SuccessIndicatorMetric(Object rawValue, String displayValue, String displayValueDescription, String code, String name) {
            this.rawValue = rawValue;
            this.displayValue = displayValue;
            this.displayValueDescription = displayValueDescription;
            this.code = code;
            this.name = name;
        }
    }

    private static class SuccessIndicatorEvaluationContext {
        private SuccessIndicatorEvaluation evaluation;
        private SuccessIndicatorMetric metric;
        private Exception failure;

        private SuccessIndicatorEvaluationContext() {
            super();
            metric = new SuccessIndicatorMetric();
        }

        private SuccessIndicatorEvaluationContext(SuccessIndicatorEvaluation evaluation) {
            this(evaluation, null);
        }

        private SuccessIndicatorEvaluationContext(SuccessIndicatorMetric metric) {
            this(null, metric);
        }

        private SuccessIndicatorEvaluationContext(SuccessIndicatorEvaluation evaluation, SuccessIndicatorMetric metric) {
            this.evaluation = evaluation;
            this.metric = metric;
            if ( this.metric == null ) {
                this.metric = new SuccessIndicatorMetric();
            }
        }
    }

    private List<EvaluatedSuccessIndicatorTO> evaluate(@Nonnull SuccessIndicator successIndicator,
                                                       @Nonnull Person person) {

        // Have struggled w/ the right cohesion level for this method. Currently responsible for building the
        // full evaluation response *and* calculating the eval itself, including selection of 'no data' and/or 'no
        // match' evaluations in the event the type specific processing produces or cannot be expected to produce an
        // evaluation. Previous revisions did split that up but ended up being difficult to name and suprisingly
        // difficult to understand. So for now it's all clumped up together.

        final List<SuccessIndicatorEvaluationContext> evaluationContexts = Lists.newLinkedList();
        try {

            final List<SuccessIndicatorMetric> metrics = findMetrics(successIndicator, person);
            if ( metrics.isEmpty() ) {

                if ( !(isWildcardedIndicator(successIndicator)) ) {
                    evaluationContexts.add(new SuccessIndicatorEvaluationContext(successIndicator.getNoDataExistsEvaluation(),
                            emptyMetricDescriptor(successIndicator)));
                }
                // otherwise return no evaluations at all. if the indicator is wildcarded, there's no pointing in
                // rendering a placeholder since the indicator itself is meaningless.

            } else {

                for ( SuccessIndicatorMetric metric : metrics ) {
                    final SuccessIndicatorEvaluationContext evaluationContext = new SuccessIndicatorEvaluationContext(metric);

                    final boolean isMetric = !(isEmptyNonNormalizedMetric(evaluationContext.metric.rawValue, successIndicator, person));
                    if ( !(isMetric) ) {
                        evaluationContext.evaluation = successIndicator.getNoDataExistsEvaluation();
                    } else {
                        // indicator value i.e. metric normalization and existence check at this layer so it can be responsible
                        // centrally for both 'no data' and 'no match' handling
                        switch ( successIndicator.getEvaluationType() ) {
                            case SCALE:

                                BigDecimal normalizedScaleMetric = null;
                                try {
                                    normalizedScaleMetric = normalizeForScaleEvaluation(evaluationContext.metric.rawValue, successIndicator);
                                } catch ( NumberFormatException e ) {
                                    // see rationale for debug level logging elsewhere in this class
                                    LOGGER.debug("Failed to find numeric representation of metric [{}] with value [{}] for person [{}] for " +
                                            "evaluation against a numeric scale using success indicator [{}]",
                                            new Object[] { evaluationContext.metric.code, evaluationContext.metric.rawValue, person.getId(),
                                                    successIndicatorLoggingId(successIndicator), e });
                                    // we have data, we just can't narrow its type for evaluation against a numeric scale, so this is
                                    // a non-match, which is handled outside the switch
                                    evaluationContext.failure = e;
                                    break;
                                } // anything else is a programmer error and we can't really distinguish between 'no data' and 'no match' so raise it

                                // shouldn't happen, but just in case, and b/c this layer is responsible for 'no data' evaluations of
                                // normalized indicator metrics
                                if ( normalizedScaleMetric == null ) {
                                    evaluationContext.evaluation = successIndicator.getNoDataExistsEvaluation();
                                } else {
                                    evaluationContext.evaluation = evaluateScale(normalizedScaleMetric, successIndicator, person);
                                }
                                break;

                            case STRING:

                                // any normalization problem is a programmer error and we can't really distinguish between 'no data' and
                                // 'no match' so raise it
                                final List<String> normalizedStringMetric = normalizeForStringEvaluation(evaluationContext.metric.rawValue, successIndicator);
                                if ( isEmptyNormalizedString(normalizedStringMetric) ) {
                                    evaluationContext.evaluation = successIndicator.getNoDataExistsEvaluation();
                                } else {
                                    evaluationContext.evaluation = evaluateString(normalizedStringMetric, successIndicator, person);
                                }
                                break;

                            default:
                                throw new UnsupportedOperationException("Unrecognized evaluation type [" +
                                        successIndicator.getEvaluationType() + "] in success indicator [" +
                                        successIndicatorLoggingId(successIndicator) + "]");

                        }
                    }

                    if ( evaluationContext.evaluation == null ) {
                        evaluationContext.evaluation = successIndicator.getNoDataMatchesEvaluation();
                    }

                    evaluationContexts.add(evaluationContext);

                }

            }

        } catch ( Exception e ) {
            // debug b/c this is completely a handled exception... if you're wondering why you're not
            // getting the evaluation statuses you expect, enable debug logging and have a look.
            LOGGER.debug("Failed to evaluate success indicator [{}] for person [{}]",
                    new Object[]{successIndicatorLoggingId(successIndicator), person.getId(), e});
            // TODO would be nice to have a better 'error' eval to return, or at least a field
            // to set on the evaluated indicator TO to indicate an error occurred so the
            // eval might be misleading
            final SuccessIndicatorEvaluationContext evaluationContext =
                    new SuccessIndicatorEvaluationContext(successIndicator.getNoDataExistsEvaluation(),
                            emptyMetricDescriptor(successIndicator));
            evaluationContext.failure = e;
            evaluationContexts.add(evaluationContext);
        }

        final List<EvaluatedSuccessIndicatorTO> indicatorTOs = Lists.newArrayListWithExpectedSize(evaluationContexts.size());
        for ( SuccessIndicatorEvaluationContext evaluationContext : evaluationContexts ) {
            final EvaluatedSuccessIndicatorTO indicatorTO = newBaseEvaluation(successIndicator, evaluationContext, person);
            indicatorTO.setDisplayValue(StringUtils.isBlank(evaluationContext.metric.displayValue)
                    ? (evaluationContext.failure == null ? "[NO DATA]" : "[ERROR]") : evaluationContext.metric.displayValue);
            indicatorTO.setEvaluation(evaluationContext.evaluation);
            indicatorTO.setEvaluationDisplayName(findEvaluationDisplayName(evaluationContext.evaluation));
            indicatorTOs.add(indicatorTO);
        }
        return indicatorTOs;
    }

    private List<SuccessIndicatorMetric> findMetrics(SuccessIndicator successIndicator, Person person) {
        switch ( successIndicator.getIndicatorGroup() ) {
            case STUDENT:
                return Lists.newArrayList(findMetricInStudentIndicatorGroup(successIndicator, person));
            case INTERVENTION:
                return Lists.newArrayList(findMetricInInterventionIndicatorGroup(successIndicator, person));
            case RISK:
                return findMetricsInRiskIndicatorGroup(successIndicator, person);
            default:
                throw new IllegalStateException("Unexpected indicator group [" +
                        successIndicator.getIndicatorGroup() + "] for indicator [" +
                        successIndicatorLoggingId(successIndicator) + "]");
        }
    }

    /**
     * Just a preliminary check of the non-normalized indicator value, i.e. metric. Has to be re-checked after
     * normalization, which is specific to SuccessIndicator#evaluationType.
     */
    private boolean isEmptyNonNormalizedMetric(@Nullable Object metric, @Nonnull SuccessIndicator successIndicator,
                                               @Nonnull Person person) {
        return metric == null || ( (metric instanceof String) && StringUtils.isBlank((String)metric) );
    }

    private SuccessIndicatorEvaluation evaluateScale(@Nonnull BigDecimal normalizedMetric,
                                                     @Nonnull SuccessIndicator successIndicator,
                                                     @Nonnull Person person) {

        SuccessIndicatorEvaluation rslt = null;
        BigDecimal from = successIndicator.getScaleEvaluationLowFrom();
        BigDecimal to = successIndicator.getScaleEvaluationLowTo();
        rslt = evaluateScaleInRange(normalizedMetric, from, to, SuccessIndicatorEvaluation.LOW);
        if ( rslt != null ) {
            return rslt;
        }

        from = successIndicator.getScaleEvaluationMediumFrom();
        to = successIndicator.getScaleEvaluationMediumTo();
        rslt = evaluateScaleInRange(normalizedMetric, from, to, SuccessIndicatorEvaluation.MEDIUM);
        if ( rslt != null ) {
            return rslt;
        }

        from = successIndicator.getScaleEvaluationHighFrom();
        to = successIndicator.getScaleEvaluationHighTo();
        rslt = evaluateScaleInRange(normalizedMetric, from, to, SuccessIndicatorEvaluation.HIGH);
        return rslt; // will be null if no match, which is handled at a higher layer

    }

    private SuccessIndicatorEvaluation evaluateScaleInRange(@Nonnull BigDecimal normalizedMetric,
                                                            @Nullable BigDecimal from, @Nullable BigDecimal to,
                                                            @Nonnull SuccessIndicatorEvaluation resultOnMatch) {
        return isInRange(normalizedMetric, from, to) ? resultOnMatch : null;
    }

    private boolean isInRange(BigDecimal metric, BigDecimal from, BigDecimal to) {
        if ( from == null && to == null ) {
            return false;
        }
        final boolean gteFrom = from == null || from.compareTo(metric) <= 0;
        return gteFrom && (to == null || to.compareTo(metric) >= 0);
    }

    private BigDecimal normalizeForScaleEvaluation(@Nullable Object metric, @Nonnull SuccessIndicator successIndicator)
            throws NumberFormatException, IllegalArgumentException {
        if ( metric == null ) {
            return null;
        }
        if ( metric instanceof Boolean ) {
            return ((Boolean)metric).booleanValue() ? BigDecimal.ONE : BigDecimal.ZERO;
        }
        if ( metric instanceof BigDecimal ) {
            return ((BigDecimal) metric);
        }
        if ( metric instanceof Number ) {
            return BigDecimal.valueOf(((Number)metric).doubleValue());
        }
        if ( metric instanceof String ) {
            return new BigDecimal((String)metric);
        }
        if ( metric instanceof Ratio ) {
            return ((Ratio)metric).ratio();
        }
        throw new NumberFormatException("Cannot interpret evaluation input value [" + metric + "] of type [" +
                metric.getClass().getName() + "] as a BigDecimal");
    }

    private SuccessIndicatorEvaluation evaluateString(@Nonnull List<String> normalizedMetric,
                                                      @Nonnull SuccessIndicator successIndicator,
                                                      @Nonnull Person person) {

        SuccessIndicatorEvaluation rslt = null;
        String evalRule = successIndicator.getStringEvaluationLow();
        rslt = evaluateStringMatchingRule(normalizedMetric, evalRule, SuccessIndicatorEvaluation.LOW, successIndicator, person);
        if ( rslt != null ) {
            return rslt;
        }

        evalRule = successIndicator.getStringEvaluationMedium();
        rslt = evaluateStringMatchingRule(normalizedMetric, evalRule, SuccessIndicatorEvaluation.MEDIUM, successIndicator, person);
        if ( rslt != null ) {
            return rslt;
        }

        evalRule = successIndicator.getStringEvaluationHigh();
        rslt = evaluateStringMatchingRule(normalizedMetric, evalRule, SuccessIndicatorEvaluation.HIGH, successIndicator, person);
        return rslt; // will be null if no match, which is handled at a higher layer

    }

    private SuccessIndicatorEvaluation evaluateStringMatchingRule(@Nonnull List<String> normalizedMetric,
                                                                  @Nullable String rawRule,
                                                                  @Nonnull SuccessIndicatorEvaluation resultOnMatch,
                                                                  @Nonnull SuccessIndicator successIndicator,
                                                                  @Nonnull Person person) {
        List<String> normalizedRule = null;
        try {
            normalizedRule = normalizeForStringEvaluation(rawRule, successIndicator);
        } catch ( RuntimeException e ) {
            // see rationale for debug level logging elsewhere in this class
            LOGGER.debug("Failed to evaluate metric [{}] for person [{}] for against " +
                    "STRING rule [{}] for result [{}] using success indicator [{}]. String rule is likely malformed.",
                    new Object[] { normalizedMetric , person.getId(), rawRule, resultOnMatch,
                            successIndicatorLoggingId(successIndicator), e });
            // rule itself is formatted badly or otherwise non-normalizable, so handle the same way we do for
            // scale evals and treat this as a 'no match'
            return null;
        }
        if ( isEmptyNormalizedString(normalizedRule) ) {
            return null;
        }
        return CollectionUtils.containsAny(normalizedMetric, normalizedRule) ? resultOnMatch : null;
    }

    private List<String> normalizeForStringEvaluation(@Nullable Object forStringEval,
                                                      @Nonnull SuccessIndicator successIndicator)
            throws IllegalArgumentException {
        if ( forStringEval == null ) {
            return Lists.newArrayListWithCapacity(0);
        }
        // TODO fix excessive List creation
        Iterable<String> translated = null;
        if ( forStringEval instanceof Boolean ) {
            translated = Lists.newArrayList(translateForStringEvaluation((Boolean) forStringEval));
        } else if ( forStringEval instanceof Ratio ) {
            final BigDecimal divided = ((Ratio)forStringEval).ratio();
            translated = Lists.newArrayList(divided.toPlainString());
        } else if ( forStringEval instanceof BigDecimal ) {
            translated = Lists.newArrayList(((BigDecimal)forStringEval).toPlainString());
        } else {
            // Otherwise skipping any sort of numeric value formatting b/c it's hard to know what sort of formatting and
            // scale people might want e.g. should we *always* format to some number of decimal points, even for int types?
            // In reality you shouldnt be using string matching for numeric metrics so whatever we do here really isn't all
            // that important, but at least this way you don't have to memorize any rules about how metric values are
            // normalized before comparison other than that they're trimmed, canonicalized to lower case, and split on
            // commas.
            //
            // Fully expect this to become more sophisticated in the future, where the SuccessIndicator specifies how
            // the metric should be normalized, e.g. to turn all the behaviors listed above on/off.

            // Thanks in part to http://eclipsesource.com/blogs/2012/07/26/having-fun-with-guavas-string-helpers/
            translated = Splitter.on(",").omitEmptyStrings().trimResults().split(forStringEval.toString());
        }
        return normalizeCasingForStringEvaluation(translated);
    }

    private List<String> normalizeCasingForStringEvaluation(Iterable<String> strings) {
        return Lists.newArrayList(Iterables.transform(strings, LOWER_CASER));
    }

    private boolean isEmptyNormalizedString(@Nullable List<String> normalizedStrings) {
        return normalizedStrings == null || normalizedStrings.isEmpty() ||
                !(Iterables.any(normalizedStrings, NON_BLANK_STRING_TEST));
    }

    private String booleanMetricDisplay(@Nullable Boolean booleanMetric) {
        return SspStringUtils.shortYesNoFromBoolean(booleanMetric);
    }

    private String translateForStringEvaluation(@Nullable Boolean bool) {
        // case canonicalization handled elsewhere to try to keep it DRY. So be sure to treat this exclusively
        // as a delegate of normalizeForStringEvaluation()
        return booleanMetricDisplay(bool);
    }

    private EvaluatedSuccessIndicatorTO newBaseEvaluation(@Nonnull SuccessIndicator successIndicator,
                                                          @Nonnull SuccessIndicatorEvaluationContext evaluationContext,
                                                          @Nonnull Person person) {
        final EvaluatedSuccessIndicatorTO indicatorTO = new EvaluatedSuccessIndicatorTO();
        indicatorTO.setPersonId(person.getId());
        indicatorTO.setIndicatorId(successIndicator.getId());
        indicatorTO.setId(indicatorTO.getIndicatorId().toString() + "::" + indicatorTO.getPersonId());
        indicatorTO.setIndicatorGroupCode(successIndicator.getIndicatorGroup());
        indicatorTO.setObjectStatus(successIndicator.getObjectStatus());
        indicatorTO.setIndicatorName(successIndicator.getName());
        indicatorTO.setIndicatorDescription(successIndicator.getDescription());
        indicatorTO.setIndicatorCode(successIndicator.getCode());
        indicatorTO.setIndicatorSortOrder(successIndicator.getSortOrder());
        indicatorTO.setIndicatorModelCode(successIndicator.getModelCode());
        indicatorTO.setIndicatorModelName(successIndicator.getModelName());
        indicatorTO.setDisplayName(evaluationContext.metric.name);
        indicatorTO.setEvaluatedIndicatorCode(evaluationContext.metric.code);
        indicatorTO.setDisplayValueDescription(evaluationContext.metric.displayValueDescription);
        return indicatorTO;
    }

    private static class Ratio {
        private BigDecimal numerator;
        private BigDecimal denominator;
        private Ratio(long numerator, long denominator) {
            this(new BigDecimal(numerator), new BigDecimal(denominator));
        }
        private Ratio(@Nonnull BigDecimal numerator, @Nonnull BigDecimal denominator) {
            this.numerator = numerator;
            this.denominator = denominator;
        }
        private BigDecimal ratio() {
            if (  BigDecimal.ZERO.compareTo(denominator) == 0  ) {
               return BigDecimal.ZERO;
            }
            return numerator.divide(denominator, DECIMAL_SCALE, ROUNDING_MODE);
        }
    }


    // Now all the indicator/metric-specific code...

    // TODO refactor to externalize per-indicator 'metric' extractions... this class is getting out of hand trying do
    // them all inline. Should have individual services register 'indicator metric providers' to perform those
    // extractions
    private SuccessIndicatorMetric findMetricInStudentIndicatorGroup(@Nonnull SuccessIndicator successIndicator,
                                                                     @Nonnull Person person) {

        switch ( successIndicator.getCode() ) {
            case "system.student.gpa":
                return findGpaMetric(successIndicator, person);
            case "system.student.registration":
                return findRegistrationMetric(successIndicator, person);
            case "system.student.creditcompletion":
                return findCreditCompletionMetric(successIndicator, person);
            case "system.student.standing":
                return findStandingMetric(successIndicator, person);
            case "system.student.sap":
                return findSapMetric(successIndicator, person);
            case "system.student.restrictions":
                return findRestrictionsMetric(successIndicator, person);
            default:
                throw new UnsupportedOperationException("Unrecognized student indicator code [" +
                        successIndicator.getCode() + "] in success indicator [" +
                        successIndicatorLoggingId(successIndicator) + "]");
        }

    }

    private SuccessIndicatorMetric findGpaMetric(@Nonnull SuccessIndicator successIndicator,
                                                 @Nonnull Person person) {
        final ExternalStudentTranscript transcript = findTranscriptFor(person);
        BigDecimal gpa = null;
        if ( transcript != null ) {
            gpa = transcript.getGradePointAverage();
        }
        return new SuccessIndicatorMetric(gpa, (gpa == null ? null : gpa.toString()), null,
                successIndicator.getCode(), successIndicator.getName());
    }

    private static enum RegistrationStatusMetric {
        NONE {
            @Override
            public RegistrationStatusMetric foundCurrent() {
                return CURRENT;
            }

            @Override
            public RegistrationStatusMetric foundFuture() {
                return FUTURE;
            }
        }, CURRENT {
            @Override
            public RegistrationStatusMetric foundFuture() {
                return CURRENT_AND_FUTURE;
            }
        }, FUTURE {
            @Override
            public RegistrationStatusMetric foundCurrent() {
                return CURRENT_AND_FUTURE;
            }
        }, CURRENT_AND_FUTURE {
            @Override
            public String screenDisplayName() {
                return "CURRENT+FUTURE";
            }
        };
        public String screenDisplayName() {
            return this.name();
        }
        public RegistrationStatusMetric foundCurrent() {
            return this;
        }
        public RegistrationStatusMetric foundFuture() {
            return this;
        }
    }

    private SuccessIndicatorMetric findRegistrationMetric(@Nonnull SuccessIndicator successIndicator,
                                                          @Nonnull Person person) {

        List<Term> currentAndFutureTerms = null;
        try {
            currentAndFutureTerms = termService.getCurrentAndFutureTerms();
        } catch ( ObjectNotFoundException e ) {
            // nothing to be done - missing terms handled below
        }

        final boolean areCurrentOrFutureTerms = currentAndFutureTerms != null && !(currentAndFutureTerms.isEmpty());

        if ( !(areCurrentOrFutureTerms) ) {
            return emptyMetricDescriptor(successIndicator);
        }

        final Map<String,Term> currentAndFutureTermsByCode = Maps.newLinkedHashMap();
        for ( Term term : currentAndFutureTerms ) {
            currentAndFutureTermsByCode.put(term.getCode(), term);
        }

        Term currentTerm = findCurrentTerm(); // if nothing found, nothing to be done - missing terms handled below

        final boolean isCurrentTerm = currentTerm != null;

        List<RegistrationStatusByTerm> regStatuses = null;
        try {
            regStatuses = registrationStatusByTermService.getCurrentAndFutureTerms(person);
        } catch ( ObjectNotFoundException e ) {
            // really shouldn't happen, but if it does, indicates all current/future terms have gone missing, so
            // handle it the same was as in that check above
            return emptyMetricDescriptor(successIndicator);
        }

        if ( regStatuses == null || regStatuses.isEmpty() ) {
            // current/future terms exist, but this person has no registration records in any of them.
            // or has zeroes in all of them. treat as if they are all zeroes
            return new SuccessIndicatorMetric(RegistrationStatusMetric.NONE.name(),
                    RegistrationStatusMetric.NONE.screenDisplayName(), null, successIndicator.getCode(),
                    successIndicator.getName());
        }

        RegistrationStatusMetric regStatusMetric = RegistrationStatusMetric.NONE;
        for ( RegistrationStatusByTerm regStatus : regStatuses ) {
            final int regCnt = regStatus.getRegisteredCourseCount();
            if ( regCnt > 0 ) {
                final String regStatusTermCode = regStatus.getTermCode();
                if ( isCurrentTerm && currentTerm.getCode().equals(regStatusTermCode)) {
                    regStatusMetric = regStatusMetric.foundCurrent();
                } else if ( currentAndFutureTermsByCode.containsKey(regStatusTermCode) ) {
                    regStatusMetric = regStatusMetric.foundFuture();
                } else {
                    // nothing to do... this reg status really shouldnt even be in the list
                }
            } else {
                // no point really in even logging this... it's a just a vanilla "no registrations in this term" record
            }
        }

        return new SuccessIndicatorMetric(regStatusMetric, regStatusMetric.screenDisplayName(), null,
                successIndicator.getCode(), successIndicator.getName());
    }

    private SuccessIndicatorMetric findCreditCompletionMetric(@Nonnull SuccessIndicator successIndicator,
                                                              @Nonnull Person person) {
        final ExternalStudentTranscript transcript = findTranscriptFor(person);
        BigDecimal completionRatio = null;
        if ( transcript != null ) {
            completionRatio = transcript.getCreditCompletionRate();
        }
        return new SuccessIndicatorMetric(completionRatio, (completionRatio == null ? null : completionRatio.toString() + "%"),
                null, successIndicator.getCode(), successIndicator.getName());
    }

    private SuccessIndicatorMetric findStandingMetric(@Nonnull SuccessIndicator successIndicator,
                                                      @Nonnull Person person) {
        final ExternalStudentTranscript transcript = findTranscriptFor(person);
        String standing = null;
        if ( transcript != null ) {
            standing = transcript.getAcademicStanding();
        }
        return new SuccessIndicatorMetric(standing, standing, null, successIndicator.getCode(), successIndicator.getName());
    }

    private SuccessIndicatorMetric findSapMetric(@Nonnull SuccessIndicator successIndicator,
                                                 @Nonnull Person person) {
        final ExternalStudentFinancialAid fa = findFinancialAidFor(person);
        String sap = null;
        if ( fa != null ) {
            sap = fa.getSapStatusCode();
        }
        return new SuccessIndicatorMetric(sap, sap, null, successIndicator.getCode(), successIndicator.getName());
    }

    private SuccessIndicatorMetric findRestrictionsMetric(@Nonnull SuccessIndicator successIndicator,
                                                          @Nonnull Person person) {
        final ExternalStudentTranscript transcript = findTranscriptFor(person);
        String restrictions = null;
        if ( transcript != null ) {
            restrictions = transcript.getCurrentRestrictions();
        }
        return new SuccessIndicatorMetric(restrictions, restrictions, null, successIndicator.getCode(), successIndicator.getName());
    }

    private SuccessIndicatorMetric findMetricInInterventionIndicatorGroup(@Nonnull SuccessIndicator successIndicator,
                                                                          @Nonnull Person person) {
        switch ( successIndicator.getCode() ) {
            case "system.intervention.intakesubmitted":
                return findIntakeSubmittedMetric(successIndicator, person);
            case "system.intervention.opentasks":
                return findOpenTasksMetric(successIndicator, person);
            case "system.intervention.openalerts":
                return findOpenAlertsMetric(successIndicator, person);
            case "system.intervention.mapstatus":
                return findMapStatusMetric(successIndicator, person);
            case "system.intervention.participation":
                return findParticipationStatusMetric(successIndicator, person);
            default:
                throw new UnsupportedOperationException("Unrecognized intervention indicator code [" +
                        successIndicator.getCode() + "] in success indicator [" +
                        successIndicatorLoggingId(successIndicator) + "]");
        }
    }

    private SuccessIndicatorMetric findIntakeSubmittedMetric(@Nonnull SuccessIndicator successIndicator,
                                                             @Nonnull Person person) {
        Date intakeSubmissionDate = person.getStudentIntakeCompleteDate();
        // Doesn't go for all boolean indicators you could imagine, but for this one there is no conceptual distinction
        // between 'no data' and 'false'
        if (intakeSubmissionDate!=null) {
            return new SuccessIndicatorMetric(new Boolean(true),
                    formatIntakeSubmissionDateForDisplay(intakeSubmissionDate), null,
                    successIndicator.getCode(), successIndicator.getName());
        } else if (person.getStudentIntakeRequestDate()!=null) {
            return new SuccessIndicatorMetric(new Boolean(false),
                    "INCOMPLETE", null,
                    successIndicator.getCode(), successIndicator.getName());
        }
        return new SuccessIndicatorMetric(null,
                formatIntakeSubmissionDateForDisplay(intakeSubmissionDate), null,
                successIndicator.getCode(), successIndicator.getName());
    }

    private String formatIntakeSubmissionDateForDisplay(@Nullable Date intakeSubmissionDate) {
        if ( intakeSubmissionDate == null ) {
            return null;
        }
        return DateOnlyFormatting.dateFormatter().format(intakeSubmissionDate);
    }

    private SuccessIndicatorMetric findOpenTasksMetric(@Nonnull SuccessIndicator successIndicator,
                                                       @Nonnull Person person) {

        // Special service method invented specifically for this use case... without it, pulling back
        // a list of actual Tasks to filter ends up taking easily half the elapsed time of the entire
        // getForPerson(). The query generated by a getAllForPerson() is nightmarish.
        final Pair<Long, Long> openVsClosed = taskService.getOpenVsClosedTaskCountsForPerson(person);

        // No conceptual difference between 'no data' and 0's here.
        final long open = openVsClosed.getFirst();
        final long closed = openVsClosed.getSecond();
        final long total = open + closed;

        final String display = new StringBuilder().append(open).append("/").append(total).toString();
        return new SuccessIndicatorMetric(open, display, null, successIndicator.getCode(), successIndicator.getName());
    }

    private SuccessIndicatorMetric findOpenAlertsMetric(@Nonnull SuccessIndicator successIndicator,
                                                           @Nonnull Person person) {
        // Would obviously need to change if we have more states in the future, but for now this is the most efficient
        // solution.
        final Number activeRaw = person.getActiveAlertsCount();
        final Number closedRaw = person.getClosedAlertsCount();

        // No conceptual difference between 'no data' and 0's here.
        final long active = activeRaw == null ? 0L : activeRaw.longValue();
        final long closed = closedRaw == null ? 0L : closedRaw.longValue();
        final long total = active + closed;

        final String display = new StringBuilder().append(active).append("/").append(total).toString();
        return new SuccessIndicatorMetric(active, display, null, successIndicator.getCode(), successIndicator.getName());
    }

    private SuccessIndicatorMetric findMapStatusMetric(SuccessIndicator successIndicator, Person person) {
        AbstractPlanStatusReportTO statusReport = null;
        try {
            statusReport = mapStatusService.getByPersonId(person.getId());
        } catch (ObjectNotFoundException e) {
            // actually means 'no such person', which means something terrible has gone wrong, but we'll treat it
            // as just a missing indicator metric
            return emptyMetricDescriptor(successIndicator);
        }
        // PlanStatus is so domain specific, we don't pass it back into the evaluate(). That function does have
        // coercion/translation/normalization capabilities, but they're all focused on very low-level types,
        // e.g. Numeric and BigDecimal, or purpose built but still very generic stuff, e.g. Ratio. So
        // we translate that enum into a name here, the same way we do it for findRegistrationMetric()

        final PlanStatus status = statusReport == null ? null : statusReport.getStatus();
        return new SuccessIndicatorMetric((status == null ? null : status.name()),
                (status == null ? null : status.getDisplayName()), null,
                successIndicator.getCode(), successIndicator.getName());
    }

    /**
     * This works differently then all other evaluations because we need to find the lowest/worst
     *  value in the student's current schedule. Essentially, we find the lowest value or match
     *    before sending to evaluate.
     *
     *    TODO: if we can speed wise, re-factor this to use the evaluation method for each course participation value
     * @param successIndicator
     * @param person
     * @return
     */
    private SuccessIndicatorMetric findParticipationStatusMetric(@Nonnull SuccessIndicator successIndicator,
                                                 @Nonnull Person person) {
        final Term currentTerm = findCurrentTerm();
        final List<ExternalStudentTranscriptCourse> scheduleCourses = externalStudentTranscriptCourseService.
                getTranscriptsBySchoolIdAndTermCode(person.getSchoolId(), currentTerm.getCode());
        String worstParticipationScore = null; //used for default null and string comparisons

        if (successIndicator.getEvaluationType().equals(SuccessIndicatorEvaluationType.SCALE)) {
            Double lowestParticipationScore = null; //used only for scale/decimal comparison

            //take lowest value found
            for (ExternalStudentTranscriptCourse courseToEvaluate : scheduleCourses) {
                try {
                    if (StringUtils.isNotBlank(courseToEvaluate.getParticipation())) {
                        double participationToEvaluate = Double.parseDouble(courseToEvaluate.getParticipation());
                        if (lowestParticipationScore == null) {
                            lowestParticipationScore = new Double(participationToEvaluate);
                        } else if (lowestParticipationScore > participationToEvaluate) {
                            lowestParticipationScore = participationToEvaluate;
                        }
                    }
                } catch (NumberFormatException nfe) {
                    //ignore for now, likely one or more records not a number
                }
            }

            return new SuccessIndicatorMetric(lowestParticipationScore, (lowestParticipationScore == null ? null : lowestParticipationScore.toString()), null,
                    successIndicator.getCode(), successIndicator.getName());

        } else if (successIndicator.getEvaluationType().equals(SuccessIndicatorEvaluationType.STRING)) {
            final String lowEval = successIndicator.getStringEvaluationLow().trim().toLowerCase();
            final String medEval = successIndicator.getStringEvaluationMedium().trim().toLowerCase();
            final String highEval = successIndicator.getStringEvaluationHigh().trim().toLowerCase();

            //take worst string value
            for (ExternalStudentTranscriptCourse courseToEvaluate : scheduleCourses) {
                if (StringUtils.isNotBlank(courseToEvaluate.getParticipation())) {
                    final String participationToEvaluate = courseToEvaluate.getParticipation().trim().toLowerCase();

                    if (StringUtils.isNotBlank(successIndicator.getStringEvaluationLow()) &&
                            participationToEvaluate.equals(lowEval)) {

                        worstParticipationScore = successIndicator.getStringEvaluationLow();
                        break;

                    } else if (StringUtils.isNotBlank(successIndicator.getStringEvaluationMedium()) &&
                            participationToEvaluate.equals(medEval)) {

                        worstParticipationScore = successIndicator.getStringEvaluationMedium();

                    } else if (StringUtils.isBlank(worstParticipationScore) &&
                            StringUtils.isNotBlank(successIndicator.getStringEvaluationHigh()) &&
                            participationToEvaluate.equals(highEval)) {

                        worstParticipationScore = successIndicator.getStringEvaluationHigh();
                    }
                }
            }
        }

        return new SuccessIndicatorMetric(worstParticipationScore, (worstParticipationScore == null ? null : worstParticipationScore.toString()), null,
                successIndicator.getCode(), successIndicator.getName());
    }

    private List<SuccessIndicatorMetric> findMetricsInRiskIndicatorGroup(@Nonnull SuccessIndicator successIndicator,
                                                                         @Nonnull Person person) {

        final Map<String, ExternalStudentRiskIndicator> externalRiskIndicators = findExternalRiskIndicatorsFor(person);

        if ( isWildcardedIndicator(successIndicator) ) {
            final List<SuccessIndicatorMetric> metrics = Lists.newLinkedList();
            for ( Map.Entry<String, ExternalStudentRiskIndicator> entry : externalRiskIndicators.entrySet() ) {
                final ExternalStudentRiskIndicator externalRiskIndicator = entry.getValue();
                if ( matchesWildcardIndicator(externalRiskIndicator, successIndicator) ) {
                    metrics.add(new SuccessIndicatorMetric(externalRiskIndicator.getIndicatorValue(),
                            externalRiskIndicator.getIndicatorValue(),
                            externalRiskIndicator.getIndicatorValueDescription(),
                            externalRiskIndicator.getIndicatorCode(),
                            wildcardedExternalRiskIndicatorDisplayName(externalRiskIndicator, successIndicator)));
                }
            }
            return metrics;
        } else {
            final ExternalStudentRiskIndicator externalRiskIndicator =
                    externalRiskIndicators.get(externalRiskMapKeyFor(successIndicator));
            if ( externalRiskIndicator == null ) {
                return Lists.newArrayList(emptyMetricDescriptor(successIndicator));
            }
            // TODO probably useful to have a way to get at the normalized representation of indicatorValue for display
            // purposes
            return Lists.newArrayList(new SuccessIndicatorMetric(externalRiskIndicator.getIndicatorValue(),
                    externalRiskIndicator.getIndicatorValue(), externalRiskIndicator.getIndicatorValueDescription(),
                    successIndicator.getCode(), successIndicator.getName()));
        }

    }

    private boolean isWildcardedIndicator(@Nonnull SuccessIndicator successIndicator) {
        // make sure this stays sync'd up with matchesWildcardIndicator() - need to use the same wildcard char.
        // also note that we intentionally only support wildcards in indicator codes not indicator *model* codes.
        // not really sure you'd ever need a wildcarded model code, but if we did support it, then we'd probably
        // need to dynamically select the model display name from the external indicator and bubble that all the
        // way up, none of which really seems like worthwhile complexity.
        return successIndicator.getCode().indexOf('*') > -1;
    }

    private boolean matchesWildcardIndicator(@Nonnull ExternalStudentRiskIndicator externalRiskIndicator,
                                             @Nonnull SuccessIndicator successIndicator) {
        final String externalRiskIndicatorModelCode = externalRiskIndicator.getModelCode();
        final String successIndicatorModelCode = successIndicator.getModelCode();
        if (!(externalRiskIndicatorModelCode.equals(successIndicatorModelCode))) { // successIndicatorModelCode can be null
            return false;
        }
        // make sure this stays sync'd up with isWildcardedIndicator() - need to use the same wildcard char
        final String externalRiskIndicatorCode = externalRiskIndicator.getIndicatorCode();
        final String successIndicatorCode = successIndicator.getCode();
        return PatternMatchUtils.simpleMatch(successIndicatorCode, externalRiskIndicatorCode);
    }

    private String wildcardedExternalRiskIndicatorDisplayName(@Nonnull ExternalStudentRiskIndicator externalRiskIndicator,
                                                              @Nonnull SuccessIndicator successIndicator) {
        return StringUtils.isBlank(externalRiskIndicator.getIndicatorName())
                ? successIndicator.getName() : externalRiskIndicator.getIndicatorName();
    }

    private Person findPersonOrFail(UUID personId) throws ObjectNotFoundException {
        try {
            final Person person = personService.get(personId);
            if ( person == null ) {
                throw new ObjectNotFoundException(personId, Person.class.getName());
            }
            return person;
        } catch ( ObjectNotFoundException e ) {
            throw e;
        }
    }

    private ExternalStudentTranscript findTranscriptFor(@Nonnull Person person) {
        final Map<String, Object> cache = evaluationResourceCache.get();
        if ( cache == null ) {
            return externalStudentTranscriptService.getRecordsBySchoolId(person.getSchoolId());
        } else {
            if ( cache.containsKey(TRANSCRIPT_INDICATOR_METRIC_KEY) ) {
                // yes, even if null
                final ExternalStudentTranscript transcript =
                        (ExternalStudentTranscript) cache.get(TRANSCRIPT_INDICATOR_METRIC_KEY);
                // Just in case threadlocal state wasn't cleared properly
                if ( transcript == null || transcript.getSchoolId().equals(person.getSchoolId()) ) {
                    return transcript;
                } else {
                    cache.remove(TRANSCRIPT_INDICATOR_METRIC_KEY);
                    // fall through
                }
            }

            final ExternalStudentTranscript transcript =
                    externalStudentTranscriptService.getRecordsBySchoolId(person.getSchoolId());
            // yes, even if null
            cache.put(TRANSCRIPT_INDICATOR_METRIC_KEY, transcript);
            return transcript;
        }
    }

    private ExternalStudentFinancialAid findFinancialAidFor(@Nonnull Person person) {
        final Map<String, Object> cache = evaluationResourceCache.get();
        if ( cache == null ) {
            return externalStudentFinancialAidService.getStudentFinancialAidBySchoolId(person.getSchoolId());
        } else {
            if ( cache.containsKey(FINANCIAL_AID_INDICATOR_METRIC_KEY) ) {
                // yes, even if null
                final ExternalStudentFinancialAid fa =
                        (ExternalStudentFinancialAid) cache.get(FINANCIAL_AID_INDICATOR_METRIC_KEY);
                // Just in case threadlocal state wasn't cleared properly
                if ( fa == null || fa.getSchoolId().equals(person.getSchoolId()) ) {
                    return fa;
                } else {
                    cache.remove(FINANCIAL_AID_INDICATOR_METRIC_KEY);
                    // fall through
                }
            }

            final ExternalStudentFinancialAid fa =
                    externalStudentFinancialAidService.getStudentFinancialAidBySchoolId(person.getSchoolId());
            // yes, even if null
            cache.put(FINANCIAL_AID_INDICATOR_METRIC_KEY, fa);
            return fa;
        }
    }

    private Map<String,ExternalStudentRiskIndicator> findExternalRiskIndicatorsFor(@Nonnull Person person) {
        final Map<String, Object> cache = evaluationResourceCache.get();
        if ( cache == null ) {
            final List<ExternalStudentRiskIndicator> esriList =
                    externalStudentRiskIndicatorService.getBySchoolId(person.getSchoolId());
            return mapOf(esriList);
        } else {
            if ( cache.containsKey(EXTERNAL_RISK_INDICATOR_METRIC_KEY) ) {
                // yes, even if null
                final Map<String,ExternalStudentRiskIndicator> esri =
                        (Map<String,ExternalStudentRiskIndicator>) cache.get(EXTERNAL_RISK_INDICATOR_METRIC_KEY);
                // Just in case threadlocal state wasn't cleared properly
                if ( esri == null || esri.isEmpty() || esri.values().iterator().next().getSchoolId().equals(person.getSchoolId()) ) {
                    return esri;
                } else {
                    cache.remove(EXTERNAL_RISK_INDICATOR_METRIC_KEY);
                    // fall through
                }
            }

            final List<ExternalStudentRiskIndicator> esriList =
                    externalStudentRiskIndicatorService.getBySchoolId(person.getSchoolId());
            final Map<String,ExternalStudentRiskIndicator> esri =  mapOf(esriList);
            cache.put(EXTERNAL_RISK_INDICATOR_METRIC_KEY, esri);
            return esri;
        }
    }

    private String findEvaluationDisplayName(@Nonnull SuccessIndicatorEvaluation evaluation) {
        final Map<String, Object> cache = evaluationResourceCache.get();
        Map<String,Blurb> blurbMap = null;
        if ( cache == null || !(cache.containsKey(EVALUATION_DISPLAY_NAMES_KEY)) ) {
            final PagingWrapper<Blurb> blurbs = blurbService.getAll(allActive(), EVALUATION_DISPLAY_NAMES_BLURB_QUERY);
            blurbMap = mapOfBlurbs(blurbs.getRows());
            if ( cache != null ) {
                cache.put(EVALUATION_DISPLAY_NAMES_KEY, blurbMap);
            }
        } else {
            blurbMap = (Map<String,Blurb>) cache.get(EVALUATION_DISPLAY_NAMES_KEY);
        }
        return evaluationDisplayNameFor(evaluation, blurbMap);
    }

    private Term findCurrentTerm() {
        final Map<String, Object> cache = evaluationResourceCache.get();
        Term currentTerm = null;

        if ( cache == null || !(cache.containsKey(CURRENT_TERM_KEY)) ) {
            try {
                currentTerm = termService.getCurrentTerm();
            } catch(ObjectNotFoundException e) {
                LOGGER.error("ERROR: CURRENT TERM NOT SET");
            }

            if ( cache != null && currentTerm != null ) {
                cache.put(CURRENT_TERM_KEY, currentTerm);
            }

        } else {
            return (Term) cache.get(CURRENT_TERM_KEY);
        }

        return currentTerm;
    }

    private String evaluationDisplayNameFor(@Nonnull SuccessIndicatorEvaluation evaluation, @Nonnull Map<String, Blurb> blurbMap) {
        final String blurbCode = new StringBuilder(EVALUATION_DISPLAY_NAMES_BLURB_PREFIX).append(BLURB_SEPARATOR).
                append(evaluation.name().toLowerCase()).toString();
        final Blurb blurb = blurbMap.get(blurbCode);
        return blurb == null ? null : blurb.getValue();
    }

    /**
     * Must generate keys that match those generated by
     * {@link #externalRiskMapKeyFor(org.jasig.ssp.model.reference.SuccessIndicator)}.
     *
     * @param esriList
     * @return
     */
    private Map<String, ExternalStudentRiskIndicator> mapOf(@Nullable List<ExternalStudentRiskIndicator> esriList) {
        return esriList == null ? Collections.EMPTY_MAP : Maps.uniqueIndex(esriList, RISK_INDICATOR_MAP_KEY_GENERATOR);
    }

    private Map<String, Blurb> mapOfBlurbs(@Nullable Collection<Blurb> blurbList) {
        return blurbList == null ? Collections.EMPTY_MAP : Maps.uniqueIndex(blurbList, BLURB_MAP_KEY_GENERATOR);
    }

    /**
     * Must generate keys that match those generated by {@link #mapOf(java.util.List)}.
     *
     * @param successIndicator
     * @return
     */
    private String externalRiskMapKeyFor(SuccessIndicator successIndicator) {
        return RISK_SUCCESS_INDICATOR_MAP_KEY_GENERATOR.apply(successIndicator);
    }

    private String successIndicatorLoggingId(@Nullable SuccessIndicator successIndicator) {
        return successIndicator == null ? null : (successIndicator.getCode() + "(" + successIndicator.getId() + ")");
    }

    private SuccessIndicatorMetric emptyMetricDescriptor(SuccessIndicator successIndicator) {
        return new SuccessIndicatorMetric(null, null, null, successIndicator.getCode(), successIndicator.getName());
    }

}
